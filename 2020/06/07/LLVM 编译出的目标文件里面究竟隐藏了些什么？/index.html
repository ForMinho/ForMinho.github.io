<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>LLVM 编译出的目标文件里面究竟隐藏了些什么？ | 琛酱的技术日志</title><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">LLVM 编译出的目标文件里面究竟隐藏了些什么？</h1><a id="logo" href="/.">琛酱的技术日志</a><p class="description">一点点在进步中的小琛酱</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">LLVM 编译出的目标文件里面究竟隐藏了些什么？</h1><div class="post-meta"><a href="/2020/06/07/LLVM%20%E7%BC%96%E8%AF%91%E5%87%BA%E7%9A%84%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2%E7%A9%B6%E7%AB%9F%E9%9A%90%E8%97%8F%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F/#comments" class="comment-count"></a><p><span class="date">Jun 07, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><p>编译器编译源代码后生成的文件叫做目标文件，从结构上讲，它是编译后的可执行文件，但还没有经过链接的过程。</p>
<p>目前iOS、Mac、iPadOS等Apple系的系统都是用mach-o文件作为目标文件；目标文件作为中间文件，它和可执行文件的内容、结构都非常相似。除了可执行文件，动态链接库、静态链接库的文件都是按照可执行文件的格式存储的。</p>
<p>使用clang 编译.out可执行文件 <code>xcrun clang SimpleSection.c</code></p>
<p>生成.o 文件： <code>clang -fmodules -c SimpleSection.c -o SimpleSection.o</code></p>
<h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><p>可以使用file 命令来查看相应的文件格式：</p>
<blockquote>
<p><code>file a.out</code></p>
<p>a.out: Mach-O 64-bit executable x86_64</p>
</blockquote>
<blockquote>
<p><code>file SimpleSection.o</code></p>
<p>SimpleSection.o: Mach-O 64-bit object x86_64</p>
</blockquote>
<h1 id="目标文件的内容"><a href="#目标文件的内容" class="headerlink" title="目标文件的内容"></a>目标文件的内容</h1><p>目标文件中除了机器指令代码、数据，还包括了链接时所需要的一些信息，包括符号表、调试信息、字符串等。目标文件按照不同的属性，以 segment 的形式存储。</p>
<p>编译后的机器指令通常放在code segment中，常见的名字以 _TEXT 作为segment name</p>
<p>全局变量和静态变量数据经常放在数据段 data segment 中，名字一般为 _DATA </p>
<p><img src="/images/mach-o_file_structure.jpg" alt=""></p>
<p>也可以使用MachOView GUI 来查看SimpleSection.o 文件</p>
<h6 id="注：MachOView-在macOS-10-15-上需要在system-preferences-gt-Security-amp-Privacy中信任该软件并打开"><a href="#注：MachOView-在macOS-10-15-上需要在system-preferences-gt-Security-amp-Privacy中信任该软件并打开" class="headerlink" title="注：MachOView 在macOS 10.15 上需要在system preferences -&gt;Security &amp; Privacy中信任该软件并打开"></a>注：MachOView 在macOS 10.15 上需要在system preferences -&gt;Security &amp; Privacy中信任该软件并打开</h6><img src="/images/mach-o_file_GUI.png"/>

<p>从图中可以看到可执行文件的开头是Mach64 Header， header描述了整个文件的文件属性，包括文件类型、目标硬件、目标操作系统等</p>
<p>Hader 之后就是Load Commands，描述了文件的各个段在文件中的偏移位置及属性，从中可以得到每个段的信息。</p>
<p>之后就是各个Section 内容，比如代码段保存的是程序的指令，数据段保存程序变量等。</p>
<p>用otool 可以看到_Text分了好几种类型，包括 _text 、__data， _Data 也分为了 _data  和 _cstring</p>
<p>不同的反编译命令也会显示不同的数据结构，如果用gobjdump 来反编译， <code>gobjdump -x SimpleSection.o</code> 部分数据则会如下，可以发现section中主要包括 .text， .data ，.cstring， .bss等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SimpleSection.o:     file format mach-o-x86-64</span><br><span class="line">SimpleSection.o</span><br><span class="line">architecture: i386:x86-64, flags 0x00000011:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address 0x0000000000000000</span><br><span class="line"> MACH-O header:</span><br><span class="line">   magic:      0xfeedfacf</span><br><span class="line">   cputype:    0x1000007 (X86_64)</span><br><span class="line">   cpusubtype: 0x3 (X86_ALL)</span><br><span class="line">   filetype:   0x1</span><br><span class="line">   ncmds:      0x4</span><br><span class="line">   sizeocmds:  0x2a8</span><br><span class="line">   flags:      0x2000</span><br><span class="line">   version:    2</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000068  0000000000000000  0000000000000000  000002c8  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, CODE</span><br><span class="line">  1 .data         00000008  0000000000000068  0000000000000068  00000330  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .cstring      00000004  0000000000000070  0000000000000070  00000338  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .bss          00000004  0000000000000120  0000000000000120  00000000  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  4 __LD.__compact_unwind 00000040  0000000000000078  0000000000000078  00000340  2**3</span><br><span class="line">                  CONTENTS, RELOC, DEBUGGING</span><br><span class="line">  5 .eh_frame     00000068  00000000000000b8  00000000000000b8  00000380  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br></pre></td></tr></table></figure>

<p>一般文件编译后的执行语句都编译成了机器代码，保存在 .text 或者是 _TEXT中；</p>
<p>已初始化的全局变量和局部变量保存在 .data或 _DATA 段中；</p>
<p>未初始化的全局变量因为默认值为0， 没有必要将他们分配在 .data 中占据空间，因此会存放在.bss段中，这个段只是为未初始化的全局变量和局部静态变量预留位置，它没有内容，也不占据内存。</p>
<p>在gobjdump 的反编译结果中存储在 .bss中，而在otool中好像没有这个段（需要大神帮忙确认和纠正）。</p>
<p>源代码在编译后主要是被分成程序指令和程序数据，代码段属于程序指令，而数据段和.bss段则数据数据程序，将数据和程序分开的主要好处有：</p>
<ol>
<li>当程序被装载之后，数据和指令分别被映射到两个虚存区域。数据区域对进程来说是可读写的，而指令区域对于进程来说则是只读的，所以这样个存储区域的权限可以分别设置，防止程序的指令被有意或无意改写。</li>
<li>对于现在的CPU来说，有着强大的缓存体系。由于缓存在现代的计算机中地位非常重要，所以程序必须尽量提高缓存命中率。指令区和数据区的分离有利于提高程序的局部性。现在CPU的缓存一般都被设计成数据缓存和指令缓存分离，所以程序指令和数据分开存放 对于CPU的缓存命中率提高也是有好处的。</li>
<li>最重要的原因是：当系统运行着多个程序时，如果它们用到的程序指令是一样的，那么内存中只需要保存一份指令就可以了。每个进程中的数据区域是不一样的，这样的话可以节省大量的内存空间。</li>
</ol>
<h1 id="深入了解目标文件"><a href="#深入了解目标文件" class="headerlink" title="深入了解目标文件"></a>深入了解目标文件</h1><p>使用 <code>gobjdump -h SimpleSection.o</code> 查看目标文件的结构和内容（本节主要使用 gobjdump 来反编译）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SimpleSection.o:     file format mach-o-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000068  0000000000000000  0000000000000000  000002c8  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, CODE</span><br><span class="line">  1 .data         00000008  0000000000000068  0000000000000068  00000330  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .cstring      00000004  0000000000000070  0000000000000070  00000338  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .bss          00000004  0000000000000120  0000000000000120  00000000  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  4 __LD.__compact_unwind 00000040  0000000000000078  0000000000000078  00000340  2**3</span><br><span class="line">                  CONTENTS, RELOC, DEBUGGING</span><br><span class="line">  5 .eh_frame     00000068  00000000000000b8  00000000000000b8  00000380  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br></pre></td></tr></table></figure>

<p>从输出的内容看，除了基础的代码段（.text）、数据段（.data）和 .bss段之外，还有只读数据段（.cstring）、 <code>__LD.__compact_unwind</code> 和 <code>eh_frame</code> 段。</p>
<p>可以先来看看看几个重要的段属性，最容易理解的是段的长度、段的起始位置 file offset，每个段的第二行还有 ”CONTENTS“ ”ALLOC” 等表示段的各个属性。</p>
<p>通过上面的信息，就可以画出段的基本分布：</p>
<p><img src="/images/SegmentOfSimpleSection_c.png" alt=""></p>
<p>如果是oc的.m 文件则又会有着与 .c文件不同的段信息，不过相同的是都会有代码段（.text _TEXT）和数据段 （.data _DATA）:</p>
<p><code>objdump -h main.o</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main.o:     file format mach-o-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000085  0000000000000000  0000000000000000  00000580  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, CODE</span><br><span class="line">  1 __DATA.__objc_classrefs 00000008  0000000000000088  0000000000000088  00000608  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, CODE, DATA</span><br><span class="line">  2 .cstring      00000014  0000000000000090  0000000000000090  00000610  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 __TEXT.__objc_methname 00000014  00000000000000a4  00000000000000a4  00000624  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, CODE, DATA</span><br><span class="line">  4 __DATA.__objc_selrefs 00000008  00000000000000b8  00000000000000b8  00000638  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, CODE, DATA</span><br><span class="line">  5 .cfstring     00000020  00000000000000c0  00000000000000c0  00000640  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, DATA</span><br><span class="line">  6 __DATA.__objc_imageinfo 00000008  00000000000000e0  00000000000000e0  00000660  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, CODE, DATA</span><br><span class="line">  7 __LD.__compact_unwind 00000020  00000000000000e8  00000000000000e8  00000668  2**3</span><br><span class="line">                  CONTENTS, RELOC, DEBUGGING</span><br><span class="line">  8 .eh_frame     00000040  0000000000000108  0000000000000108  00000688  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br></pre></td></tr></table></figure>

<p>同样我们也可以画出它的段分布图：</p>
<p><img src="/images/SegmentOfSectionInMain_m.png" alt=""></p>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>通过 <code>objdump -s -d SimpleSection.o</code>将所有段的内容以十六进制方式打印出来（参数 -s），同事还可以将包含指令的段反汇编（参数 -d），以下为代码段的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Contents of section .text:</span><br><span class="line"> 0000 554889e5 4883ec10 897dfc8b 75fc488d  UH..H....&#125;..u.H.</span><br><span class="line"> 0010 3d5b0000 00b000e8 00000000 4883c410  &#x3D;[..........H...</span><br><span class="line"> 0020 5dc3662e 0f1f8400 00000000 0f1f4000  ].f...........@.</span><br><span class="line"> 0030 554889e5 4883ec10 c745fc00 000000c7  UH..H....E......</span><br><span class="line"> 0040 45f80100 00008b05 00000000 03050000  E...............</span><br><span class="line"> 0050 00000345 f80345f4 89c7e800 0000008b  ...E..E.........</span><br><span class="line"> 0060 45f84883 c4105dc3                    E.H...].        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;_func1&gt;:</span><br><span class="line">   0:    55                       push   %rbp</span><br><span class="line">   1:    48 89 e5                 mov    %rsp,%rbp</span><br><span class="line">   4:    48 83 ec 10              sub    $0x10,%rsp</span><br><span class="line">   8:    89 7d fc                 mov    %edi,-0x4(%rbp)</span><br><span class="line">   b:    8b 75 fc                 mov    -0x4(%rbp),%esi</span><br><span class="line">   e:    48 8d 3d 5b 00 00 00     lea    0x5b(%rip),%rdi        # 70 &lt;_main.static_var+0x4&gt;</span><br><span class="line">  15:    b0 00                    mov    $0x0,%al</span><br><span class="line">  17:    e8 00 00 00 00           callq  1c &lt;_func1+0x1c&gt;</span><br><span class="line">  1c:    48 83 c4 10              add    $0x10,%rsp</span><br><span class="line">  20:    5d                       pop    %rbp</span><br><span class="line">  21:    c3                       retq   </span><br><span class="line">  22:    66 2e 0f 1f 84 00 00     nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  29:    00 00 00 </span><br><span class="line">  2c:    0f 1f 40 00              nopl   0x0(%rax)</span><br><span class="line"></span><br><span class="line">0000000000000030 &lt;_main&gt;:</span><br><span class="line">  30:    55                       push   %rbp</span><br><span class="line">  31:    48 89 e5                 mov    %rsp,%rbp</span><br><span class="line">  34:    48 83 ec 10              sub    $0x10,%rsp</span><br><span class="line">  38:    c7 45 fc 00 00 00 00     movl   $0x0,-0x4(%rbp)</span><br><span class="line">  3f:    c7 45 f8 01 00 00 00     movl   $0x1,-0x8(%rbp)</span><br><span class="line">  46:    8b 05 00 00 00 00        mov    0x0(%rip),%eax        # 4c &lt;_main+0x1c&gt;</span><br><span class="line">  4c:    03 05 00 00 00 00        add    0x0(%rip),%eax        # 52 &lt;_main+0x22&gt;</span><br><span class="line">  52:    03 45 f8                 add    -0x8(%rbp),%eax</span><br><span class="line">  55:    03 45 f4                 add    -0xc(%rbp),%eax</span><br><span class="line">  58:    89 c7                    mov    %eax,%edi</span><br><span class="line">  5a:    e8 00 00 00 00           callq  5f &lt;_main+0x2f&gt;</span><br><span class="line">  5f:    8b 45 f8                 mov    -0x8(%rbp),%eax</span><br><span class="line">  62:    48 83 c4 10              add    $0x10,%rsp</span><br><span class="line">  66:    5d                       pop    %rbp</span><br><span class="line">  67:    c3                       retq</span><br></pre></td></tr></table></figure>

<p>“Contents  of section.text” 就是 .text的数据以十六进制方式打印出来的内容，其中最左面一列是偏移量，中间4列是十六进制内容，最右面一列是 .text段的 ASCII码形式。对照反汇编结果，可以明显看到， .text段锁包含的正是 SimpleSection.c文件的两个函数 func1()和 main() 指令。 .text段的第一个字节 0x55 就是func1()的第一条 </p>
<p><code>push   %rbp</code> 指令，而最后一个自己 0xc3则是 main()函数的最后一条指令 <code>retq</code> </p>
<h2 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h2><p>.data 段保存了已经初始化的全局静态变量和局部静态变量。在 SimpleSection.c文件中， global_init_var 和 static_var 都已经初始化了，所以保存在.data字段当中</p>
<p>int类型数据占4个字节，两个变量总共占8个字节，与上文反编译SimpleSection.o 中的.data段 size 相同。</p>
<p>在SimpleSection.c 中调用printf的时候，用到了字符常量 <code>%d\n</code>, 这是一种只读数据，所以存放在 .cstring中。</p>
<h1 id="目标文件的结构"><a href="#目标文件的结构" class="headerlink" title="目标文件的结构"></a>目标文件的结构</h1><p>目标文件的第一部分是文件头，在Apple 相关的目标文件中，叫做Mach header，描述了文件的基本属性，包括文件类型、目标机器型号等。</p>
<p>接着是Load Commands，里面包括了各个段（Segment）的基本信息，包括offset、size等；</p>
<p>接下来就是各个段的具体信息。</p>
<p>具体的定义声明在 mach-o/loader.h 文件中。</p>
<h2 id="文件头（mach-header）"><a href="#文件头（mach-header）" class="headerlink" title="文件头（mach header）"></a>文件头（mach header）</h2><p>以SimpleSection.c 的目标文件为例，使用 <code>gobjdump -p SimpleSection.o</code> 得到其header：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SimpleSection.o:     file format mach-o-x86-64</span><br><span class="line"> MACH-O header:</span><br><span class="line">   magic:      0xfeedfacf</span><br><span class="line">   cputype:    0x1000007 (X86_64)</span><br><span class="line">   cpusubtype: 0x3 (X86_ALL)</span><br><span class="line">   filetype:   0x1</span><br><span class="line">   ncmds:      0x4</span><br><span class="line">   sizeocmds:  0x2a8</span><br><span class="line">   flags:      0x2000</span><br><span class="line">   version:    2</span><br></pre></td></tr></table></figure>



<p>Mach-O文件的header 结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header_64 &#123;</span><br><span class="line">    uint32_t    magic;      &#x2F;* mach magic number identifier *&#x2F;</span><br><span class="line">    cpu_type_t  cputype;    &#x2F;* cpu specifier *&#x2F;</span><br><span class="line">    cpu_subtype_t   cpusubtype; &#x2F;* machine specifier *&#x2F;</span><br><span class="line">    uint32_t    filetype;   &#x2F;* type of file *&#x2F;</span><br><span class="line">    uint32_t    ncmds;      &#x2F;* number of load commands *&#x2F;</span><br><span class="line">    uint32_t    sizeofcmds; &#x2F;* the size of all the load commands *&#x2F;</span><br><span class="line">    uint32_t    flags;      &#x2F;* flags *&#x2F;</span><br><span class="line">    uint32_t    reserved;   &#x2F;* reserved *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct load_command &#123;</span><br><span class="line"> 	uint32_t cmd;		&#x2F;* type of load command *&#x2F;</span><br><span class="line"> 	uint32_t cmdsize;	&#x2F;* total size of command in bytes *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Load Commands 是Mach-O 文件中非常重要的部分，文档中对于这个结构体的定义为：</p>
<blockquote>
<p>/*</p>
<ul>
<li>The load commands directly follow the mach_header.  The total size of all</li>
<li>of the commands is given by the sizeofcmds field in the mach_header.  All</li>
<li>load commands must have as their first two fields cmd and cmdsize.  The cmd</li>
<li>field is filled in with a constant for that command type.  Each command type</li>
<li>has a structure specifically for it.  The cmdsize field is the size in bytes</li>
<li>of the particular load command structure plus anything that follows it that</li>
<li>is a part of the load command (i.e. section structures, strings, etc.).  To</li>
<li>advance to the next load command the cmdsize can be added to the offset or</li>
<li>pointer of the current load command.  The cmdsize for 32-bit architectures</li>
<li>MUST be a multiple of 4 bytes and for 64-bit architectures MUST be a multiple</li>
<li>of 8 bytes (these are forever the maximum alignment of any load commands).</li>
<li>The padded bytes must be zero.  All tables in the object file must also</li>
<li>follow these rules so the file can be memory mapped.  Otherwise the pointers</li>
<li>to these tables will not work well or at all on some machines.  With all</li>
<li>padding zeroed like objects will compare byte for byte.</li>
<li>/</li>
</ul>
</blockquote>
<p>翻译过来后的大概意思是：</p>
<p>load commands 的大小和 header中的sizeofcmds 相等。所有的load command 必须包括cmd 和 cmdsize 两个参数。cmd 的type 在loader.h文件中有具体的define</p>
<p>cmdsize 中以字节为单位，包含了load command的部分信息，包括 section结构、strings 等，可以通过当前load command的 offset + size 得到下一个的cmdsize 信息。</p>
<p>可以通过 <code>otool -l SimpleSection.o</code> 查看所有的load command</p>
<h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><p>段表是目标文件中非常重要的结构，通过上文克制，目标文件的段主要包括 .text，.data段，对于每个段的具体信息，包括section name，segment name， size， offset等；这些信息主要保存在 load commands 中，可以通过命令行查看，也可以通过MachOView来查看。</p>
<p><img src="/images/infoOfSections.png" alt=""></p>
<p>具体结构定义也存在于 Loader.h 文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct section &#123; &#x2F;* for 32-bit architectures *&#x2F;</span><br><span class="line">  char sectname[16]; &#x2F;* name of this section *&#x2F;</span><br><span class="line">  char segname[16]; &#x2F;* segment this section goes in *&#x2F;</span><br><span class="line">  uint32_t addr; &#x2F;* memory address of this section *&#x2F;</span><br><span class="line">  uint32_t size; &#x2F;* size in bytes of this section *&#x2F;</span><br><span class="line">  uint32_t offset; &#x2F;* file offset of this section *&#x2F;</span><br><span class="line">  uint32_t align; &#x2F;* section alignment (power of 2) *&#x2F;</span><br><span class="line">  uint32_t reloff; &#x2F;* file offset of relocation entries *&#x2F;</span><br><span class="line">  uint32_t nreloc; &#x2F;* number of relocation entries *&#x2F;</span><br><span class="line">  uint32_t flags; &#x2F;* flags (section type and attributes)*&#x2F;</span><br><span class="line">  uint32_t reserved1; &#x2F;* reserved (for offset or index) *&#x2F;</span><br><span class="line">  uint32_t reserved2; &#x2F;* reserved (for count or sizeof) *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct section_64 &#123; &#x2F;* for 64-bit architectures *&#x2F;</span><br><span class="line">  char sectname[16]; &#x2F;* name of this section *&#x2F;</span><br><span class="line">  char segname[16]; &#x2F;* segment this section goes in *&#x2F;</span><br><span class="line">  uint64_t addr; &#x2F;* memory address of this section *&#x2F;</span><br><span class="line">  uint64_t size; &#x2F;* size in bytes of this section *&#x2F;</span><br><span class="line">  uint32_t offset; &#x2F;* file offset of this section *&#x2F;</span><br><span class="line">  uint32_t align; &#x2F;* section alignment (power of 2) *&#x2F;</span><br><span class="line">  uint32_t reloff; &#x2F;* file offset of relocation entries *&#x2F;</span><br><span class="line">  uint32_t nreloc; &#x2F;* number of relocation entries *&#x2F;</span><br><span class="line">  uint32_t flags; &#x2F;* flags (section type and attributes)*&#x2F;</span><br><span class="line">  uint32_t reserved1; &#x2F;* reserved (for offset or index) *&#x2F;</span><br><span class="line">  uint32_t reserved2; &#x2F;* reserved (for count or sizeof) *&#x2F;</span><br><span class="line">  uint32_t reserved3; &#x2F;* reserved *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<p>注： 本次编译用到的code 如下：</p>
<ol>
<li>file name：SimpleSection.c</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int global_init_var &#x3D; 84;</span><br><span class="line">int global_uninit_var;</span><br><span class="line">void func1( int i )</span><br><span class="line">&#123;</span><br><span class="line">    printf( &quot;%d\n&quot;,  i );</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    static int static_var &#x3D; 85;</span><br><span class="line">    static int static_var2;</span><br><span class="line">    int a &#x3D; 1;</span><br><span class="line">    int b;</span><br><span class="line">    </span><br><span class="line">    func1( static_var + static_var2 + a + b );</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>file name: main.m</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">#define DEFINEEight 8</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int eight &#x3D; DEFINEEight;</span><br><span class="line">        int six &#x3D; 6;</span><br><span class="line">        double number;</span><br><span class="line">        NSString* site &#x3D; [[NSString alloc] initWithUTF8String:&quot;starming&quot;];</span><br><span class="line">        int rank &#x3D; eight + six;</span><br><span class="line">        NSLog(@&quot;%@ rank %d&quot;, site, rank);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本文参考： <a href="https://github.com/ming1016/study/wiki/Apple-操作系统可执行文件-Mach-O" target="_blank" rel="noopener">https://github.com/ming1016/study/wiki/Apple-操作系统可执行文件-Mach-O</a></p>
</div><div class="post-copyright"><blockquote><p>Original author: For_Minho</p><p>Original link: <a href="http://yoursite.com/2020/06/07/LLVM 编译出的目标文件里面究竟隐藏了些什么？/">http://yoursite.com/2020/06/07/LLVM 编译出的目标文件里面究竟隐藏了些什么？/</a></p><p>Copyright Notice: Please indicate the source of the reprint (must retain the author's signature and link)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>Share:</span></div></div><div class="post-nav"><a href="/2020/05/28/%E5%BD%93%E6%88%91%E4%BB%AC%E6%8C%89%E4%B8%8BCommand+B%E5%90%8E%EF%BC%8CXcode%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/" class="next">当我们按下Command+B后，Xcode 做了什么？</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#文件格式"><span class="toc-text">文件格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#目标文件的内容"><span class="toc-text">目标文件的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#注：MachOView-在macOS-10-15-上需要在system-preferences-gt-Security-amp-Privacy中信任该软件并打开"><span class="toc-text">注：MachOView 在macOS 10.15 上需要在system preferences -&gt;Security &amp; Privacy中信任该软件并打开</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#深入了解目标文件"><span class="toc-text">深入了解目标文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#代码段"><span class="toc-text">代码段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据段和只读数据段"><span class="toc-text">数据段和只读数据段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#目标文件的结构"><span class="toc-text">目标文件的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#文件头（mach-header）"><span class="toc-text">文件头（mach header）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Load-Commands"><span class="toc-text">Load Commands</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#段表"><span class="toc-text">段表</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/07/LLVM%20%E7%BC%96%E8%AF%91%E5%87%BA%E7%9A%84%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2%E7%A9%B6%E7%AB%9F%E9%9A%90%E8%97%8F%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F/">LLVM 编译出的目标文件里面究竟隐藏了些什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/%E5%BD%93%E6%88%91%E4%BB%AC%E6%8C%89%E4%B8%8BCommand+B%E5%90%8E%EF%BC%8CXcode%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/">当我们按下Command+B后，Xcode 做了什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/25/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">《程序员的自我修养》线程基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/25/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">《程序员的自我修养》基础知识</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">4</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">For_Minho.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>