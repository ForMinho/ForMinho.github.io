<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><title>《程序员的自我修养》基础知识 | 琛酱的技术日志</title><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《程序员的自我修养》基础知识</h1><a id="logo" href="/.">琛酱的技术日志</a><p class="description">一点点在进步中的小琛酱</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">《程序员的自我修养》基础知识</h1><div class="post-meta"><a href="/2020/05/25/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#comments" class="comment-count"></a><p><span class="date">May 25, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><p>最近在重新阅读《程序员的自我修养》这本书，此前虽然只是读，但是并没有认真的记录笔记，因此本次的读书将要更为细致的记录自己的领悟。</p>
<h2 id="关于硬件设备"><a href="#关于硬件设备" class="headerlink" title="关于硬件设备"></a>关于硬件设备</h2><p>计算机有着非常复杂的设备、芯片以及外围接口，站在软件开发的角度来看，计算机硬件最主要的部分为：CPU （中央处理器）、内存和I/O 控制芯片</p>
<h3 id="1-早期计算机处理功能相对较弱时"><a href="#1-早期计算机处理功能相对较弱时" class="headerlink" title="1. 早期计算机处理功能相对较弱时"></a>1. 早期计算机处理功能相对较弱时</h3><p>早期的计算机没有复杂的图形功能，CPU的核心频率与内存频率一样，不是很高，同时由于I/O 设备的速度比CPU 和内存要低很多，所以当时为了协调I/O设备与总线之间的速度，每个设备都会有一个相应的I/O控制器。</p>
<h3 id="2-南北桥诞生"><a href="#2-南北桥诞生" class="headerlink" title="2. 南北桥诞生"></a>2. 南北桥诞生</h3><p>随着CPU核心频率的提升，导致内存跟不上CPU的速度，于是产生了与内存频率一致的系统总线，而CPU采用倍频的方式与系统总线进行通信。接着图形化操作系统的普及，导致图形芯片需要跟CPU和内存之间进行大量的数据交换，慢速的I/O总线无法满足图形设备的巨大需求。 为了协调CPU、内存和高速的图形设备，因此高速的北桥芯片诞生，从而使他们之间可以高速交换数据。</p>
<p>由于北桥运行速度比较高，如果相对低速的设备连接在北桥上，北桥既需要处理高速设备，又要处理低速设备，设计就会非常复杂，处理低速设备的南桥因此而诞生，磁盘、USB、键盘、鼠标等设备连接在南桥上，由南桥将其汇总后连接到北桥上。</p>
<p><img src="/images/CPUBridge.jpg" alt=""></p>
<h3 id="3-南北桥与CPU整合"><a href="#3-南北桥与CPU整合" class="headerlink" title="3. 南北桥与CPU整合"></a>3. 南北桥与CPU整合</h3><p>随着amd的主板取消北桥，将其合并到CPU，也有很多厂家直接将南桥取消。 因此现在的很多主板上是无法再看到南北桥的身影了。</p>
<h2 id="硬盘结构和文件系统"><a href="#硬盘结构和文件系统" class="headerlink" title="硬盘结构和文件系统"></a>硬盘结构和文件系统</h2><p>硬盘的基本存储单位为扇区，每个扇区一般为512个字节，一个硬盘往往有多个盘片，每个盘片分为两面，每面按照同心圆划分为若干个磁道，每个磁道划分为若干个扇区。</p>
<p>举个例子： 如果一个硬盘有2个盘片，每个盘面分65 536 个磁道，每个磁道分1024个扇区，那么硬盘的容量为： 2 * 2 * 65 536 * 1024 * 512  = 137 438 953 472字节（128GB）</p>
<p>但是这样就会有一个问题，那就是每个盘面上同心圆的周长不一样，如果每个磁道都拥有相同数量的扇区，那么靠近盘面外围的磁道密度肯定比内圈更加稀疏，这样就会非常浪费空间；如果不同的磁道扇区数又不同，计算起来又会十分的麻烦，为了屏蔽这些技术细节，现代硬盘采用了一种叫做 LBA(Logical Block Address)的方式，整个硬盘中所有的扇区从0开始编号，一直到最后一个扇区，这个扇区编号叫做逻辑扇区号。逻辑扇区号抛弃了复杂的磁道、盘面概念，因此当给出一个逻辑扇区号时，硬盘就会将其转化为实际的盘面、磁道等具体位置。</p>
<p>文件系统作为操作系统最重要的组成部分，管理着磁盘中文件的存储方式，其保存了文件的存储结构，并负责这些数据结构，同时保证磁盘中的扇区能够有效地组织和利用。</p>
<p>例如在Linux 中有一个文件： test.data，长度为8000个字节，那么Linux 的ext3 文件有可能按照这样的方式储存在磁盘中： 文件的前4096字节存储在磁盘的1000号扇区到10007扇区，每个扇区512个字节，8个扇区刚好4096字节，文件的第4097字节到第8000字节共3904个字节，存储在磁盘的2000号扇区到2007号扇区，8个扇区也是4096个字节，只不过只存储了3094个有效字节，剩余的912个字节无效。</p>
<p>读取文件的步骤：</p>
<ol>
<li>在Linux操作系统中，要读取这个文件的前4096个字节时，会使用 read的系统调用来实现，文件系统在收到read 请求之后，判断出文件的前4096个字节位于磁盘的1000号逻辑扇区到1007号逻辑扇区。</li>
<li>文件系统会向硬盘驱动发出读取逻辑扇区为1000号开始的8个扇区的请求，驱动程序收到这个请求后向硬盘发出硬件命令。</li>
<li>硬盘收到命令后，执行相应的操作，并将数据读取到实现设置好的内存地址中。</li>
</ol>
<p>向硬盘发出I/O命令的方式有很多种，最常见的是通过读写I/O端口寄存器来实现。例如在x86平台，共有65 563个硬件端口寄存器，不同的硬件被分配到了不同的I/O端口地址。CPU 提供了“in” 和 “out”两条指令来实现对硬件端口的读和写。</p>
<p>对IDE来说，有IDE0和IDE1两个通道，每个通道可以连接两个设备，分别为Master和 Slave，一个PC最多可以有4个IDE设备，例如我们的文件位于IDE0的Master硬盘上，在PC中，IDE0通道的I/O端口地址是0x1F0 ~ 0x1F7及 0x376 ~ 0x377， 通过读写这些端口地址就能与IDE硬盘进行通信。以实现读取1000号逻辑扇区开始的8个扇区为例：</p>
<p>A.  第0x1F3 ~ 0x1F6 4个字节的端口地址是用来写入LBA（逻辑扇区地址）的，那么1000号逻辑扇区的LBA地址为0x000003E8(16 进制)，所以需要往0x1F3、 0x1F4写入0x00， 往0x1F5写入0x03，往0x1F6写入 0xE8.</p>
<p>B.  0x1F2这个地址用来写入需要读写的扇区数，在当前的例子中是8个扇区，因此写入8</p>
<p>C. 0x1F7 这个地址写入要执行的操作命令码，读取操作的命令码为0x20，因此写入 0x20；</p>
<p>所以我们要执行的指令为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">out  0x1F3, 0x00</span><br><span class="line">out  0x1F4, 0x00</span><br><span class="line">out  0x1F5, 0x03</span><br><span class="line">out  0x1F6, 0xE8</span><br><span class="line">out  0x1F2, 0x08</span><br><span class="line">out  0x1F7, 0x20</span><br></pre></td></tr></table></figure>



<h2 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h2><blockquote>
<p>“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”， 这句名言真切的概括了计算机系统软件体系结构的设计要点。</p>
</blockquote>
<p>不只是计算机系统软件的整体体系是这样，体系里面的组件如操作系统本身，应用程序、系统软件等都是按照这种层次结构组织设计的，如网络体系，应用程序体系等。</p>
<p>每个层次之间为了互相通信，所以必须要定义通信协议，这就是我们常说的接口（Interface），接口的下面那层是接口的提供者，由它定义接口并实现；接口的上层是接口的使用者，它使用接口来实现所需要的功能。 在层次体系统，接口是被精心设计的，尽量保持不变，因为只要层次之间遵循接口协议，任何一个层都可以被修改或者是替换掉。</p>
<p>除了硬件和应用程序，其它层都是中间层，每个中间层都是对它下面那层的包装和使用。正是由于这些中间层的存在，才使得应用程序和硬件之间能够保持相对的独立。</p>
<h2 id="CPU-进化史"><a href="#CPU-进化史" class="headerlink" title="CPU 进化史"></a>CPU 进化史</h2><p>操作系统的主要有两个功能，其中一个是提供抽象的接口，另一个则是管理硬件资源。 计算机硬件的能力是优先的，比如一个CPU一秒钟能够执行的指令条数是1亿条或者是1GB的内存能够最多同时存储1GB的数据。无论如何使用，资源总量是确定的。因此如何能够在更短的时间里处理更多的任务，是计算机发展的目标。</p>
<p>CPU作为非常昂贵的资源，如果让CPU空闲下来，对于资源的浪费是巨大的，因此如何让CPU持续不断地工作，是计算机发展早期的难题。</p>
<h3 id="1-多道程序"><a href="#1-多道程序" class="headerlink" title="1. 多道程序"></a>1. 多道程序</h3><p> 早期的计算机一次只能运行一个程序，所以当程序读写数据时，CPU就闲下来了，这对于CPU的利用是非常低效的，因此人们编写了监控层序，当某个程序暂时不使用CPU时，监控程序就把另外的正在等待CPU资源的程序启动，使得CPU可以充分利用起来， 这被称为多道程序，在当时大大提高了CPU的利用率。 不过多道程序最大的问题在于程序之间的调度策略太过粗暴，对于多道程序来说，程序之间并没有轻重缓急，有些急需使用CPU的程序可能要很长时间以后才能分配到CPU。</p>
<h3 id="2-分时系统"><a href="#2-分时系统" class="headerlink" title="2. 分时系统"></a>2. 分时系统</h3><p>在多道程序的基础上，稍作改进，程序运行模式变为了每个程序运行一段时间以后都会主动让出CPU，这就使得每个程序都有机会运行一小段时间，这对于交互式的任务比如鼠标点击或者是按下键盘立即处理非常重要。这种程序协作模式叫做分时系统。 Mac OS X之前的版本都是采用这种分时系统来调度程序的。 但是分时系统有一个很大的缺点： 如果一个程序在进行耗时操作，一直占用着CPU，操作系统也没有办法将CPU切换给其他程序，那么这时操作系统就好像是死机了一样。 这对于用户的操作体验来讲是非常差的，系统的任何一个程序死循环都有可能导致系统死机。 不过当时PC的硬件处理能力比较弱，应用大多数也比较低端，因此分时系统的方法也可以勉强处理一下。</p>
<h3 id="3-多任务系统"><a href="#3-多任务系统" class="headerlink" title="3. 多任务系统"></a>3. 多任务系统</h3><p>这种模式是我们非常熟悉的，操作系统接管了所有的硬件资源，并且本身运行在受硬件保护的级别。所有的应用程序都是以进程的方式运行在比操作系统权限低级别，每个进程都有自己独立的地址空间，使得进程之间的地址空间相互隔离。 CPU由操作系统进行分配，每个进程根据优先级的高低都有机会得到CPU； 系统采取抢占式的分配方式，如果一个进程的运行时间超出了给定时间，操作系统就会暂停该进程，将CPU资源分配给其他正在等待中的进程。</p>
<h2 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h2><p>进程的总体目标是希望每个进程从逻辑上来看都可以独占计算机的资源； 操作系统的多任务功能使CPU可以在多个进程之间进行共享，操作系统的I/O 抽象模型也可以很好地实现I/O设备的共享和抽象，那么剩下的问题就是内存分配问题了。</p>
<h3 id="1-内存隔离"><a href="#1-内存隔离" class="headerlink" title="1. 内存隔离"></a>1. 内存隔离</h3><p>对应用程序来说，在运行时不希望去处理复杂的存储器管理过程，而只是需要一个简单的执行环境： 单一的地址空间、CPU。</p>
<p>地址空间是分为两种： 虚拟地址空间和物理地址空间。</p>
<p>物理地址是真实存在于计算机中的，可以把物理空间想象成物理内存，比如说使用的计算机是Intel Pentium4 32位处理器，即计算机地址线有32条（实际有36条地址线，不过暂时可以认为只有32条），那么物理空间就有4GB，但是计算机只装了512M的内存，那么物理地址真正有效的只有 0x00000000～0x1FFFFFFF， 其他部分都是无效的。</p>
<p>虚拟地址空间是虚拟的、想象出来地址空间，实际上并不存在，每个进程都有自己独立的虚拟空间，每个进程只能访问自己的地址空间，这样通过在物理地址的基础上增加中间层——虚拟地址，从而使程序与物理地址之间实现了隔离。</p>
<p>通过映射方法，就能够控制从虚拟地址到物理地址的映射过程。</p>
<h3 id="2-在有限的内存中运行更多的程序"><a href="#2-在有限的内存中运行更多的程序" class="headerlink" title="2. 在有限的内存中运行更多的程序"></a>2. 在有限的内存中运行更多的程序</h3><p>假设计算机有128M内存，程序A运行需要10MB，程序B需要100MB，程序C需要20MB。如果需要同时运行程序A和B，那么比较直接的做法是将内存的前10MB分配给程序A，10MB~ 110MV分配给B，这样就能够实现A和B程序的同时运行，但是如果此时要运行程序C，这时的内存空间其实已经不够了，可以用的方法只能是将其他程序的数据暂时写入到硬盘中，等到需要的时候再读取回来，如果程序所需要的空间是连续的，那么将程序A写入到硬盘中所释放的资源并不能运行C，因此只能将B换出，此时将会有大量的数据换入换出操作，会导致效率十分低下。</p>
<h4 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h4><p>早起人们采用了分段的方式管理内存。基本的思路就是将一段与程序所需要内存空间大小相等的虚拟空间映射到某个地址空间。比如程序A需要10MB的内存，那么假设有一个地址从 0x00000000到0x00A00000的10MB的虚拟空间，然后在实际的物理地址中分配相同大小的物理地址，然后将两块相同大小的地址空间一一映射，这个映射过程由操作系统来设置映射函数，实际地址转换由硬件完成。那么当程序A在访问地址 0x00001000， CPU就会将这个地址转换成实际的物理地址，那么程序A和B在运行时，他们的虚拟空间和物理空间的映射关系可能为：</p>
<p><img src="/images/segmentAddress.jpg" alt=""></p>
<p>分段方式并没有解决内存使用效率的问题，分段对内存区域的映射还是按照程序为单位的，内存不足导致的数据换入换出操作，会影响效率，这种方法还是相对粗糙的，粒度比较大；事实上，当一个程序在运行时，在某一时间段内，只是频繁的用到了一小部分数据，程序的很多数据都是不会被用到的，因此可以做更小粒度的内存分割和映射，使得程序局部性原理得到充分的利用，从而大大提高内存的使用率，这就是分页。</p>
<h4 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h4><p>分页管理的基本方式就是将地址空间认为的等分为固定大小的页，页的大小由硬件决定，目前的PC操作系统都是使用4KB大小的页，如果使用的是32位虚拟地址空间，也就是4GB，如果按照4KB大小进行分页，那么就会有1 048 576个页。</p>
<p>把常用的数据和代码页装载到内存中，把不常用的代码和数据保存在硬盘中，当需要的使用再把他们从硬盘中取出来。</p>
<p>如图所示有两个进程： process1 和 process2， 在他们的进程中部分虚拟页面被映射到了物理页面，比如process1 的VP0、 VP1 和VP7， 而有部分页面在硬盘中，比如VP2和VP3，另外还有一些页面 VP4 和VP5可能并没有用到或者访问到，因此他们暂时处于未使用状态。 Process1 的VP2 和 VP3并不在内存中，当进程需要这两个页的时候，硬件会捕获到这个消息，即页错误，操作系统接管进程，负责将VP2 和 VP3从硬盘中读取出来并装载入内存，然后将两个页与VP2 和 VP3建立映射关系。 </p>
<p><img src="/images/PagingAddress.jpg" alt=""></p>
<p>页为单位不仅数据存取和交换非常方便，同时也可以为其提供保护，每个页都可以设置权限属性，而权限属性只能由操作系统修改，那么就能从根本上保护进程。</p>
</div><div class="post-copyright"><blockquote><p>Original author: For_Minho</p><p>Original link: <a href="http://yoursite.com/2020/05/25/基础知识/">http://yoursite.com/2020/05/25/基础知识/</a></p><p>Copyright Notice: Please indicate the source of the reprint (must retain the author's signature and link)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>Share:</span></div></div><div class="post-nav"><a href="/2020/05/25/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="pre">《程序员的自我修养》线程基础</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于硬件设备"><span class="toc-text">关于硬件设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-早期计算机处理功能相对较弱时"><span class="toc-text">1. 早期计算机处理功能相对较弱时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-南北桥诞生"><span class="toc-text">2. 南北桥诞生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-南北桥与CPU整合"><span class="toc-text">3. 南北桥与CPU整合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#硬盘结构和文件系统"><span class="toc-text">硬盘结构和文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#软件体系结构"><span class="toc-text">软件体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-进化史"><span class="toc-text">CPU 进化史</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-多道程序"><span class="toc-text">1. 多道程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-分时系统"><span class="toc-text">2. 分时系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-多任务系统"><span class="toc-text">3. 多任务系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存问题"><span class="toc-text">内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-内存隔离"><span class="toc-text">1. 内存隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-在有限的内存中运行更多的程序"><span class="toc-text">2. 在有限的内存中运行更多的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分段管理"><span class="toc-text">分段管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分页管理"><span class="toc-text">分页管理</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/07/10/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/">动态链接</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/01/%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">关于静态链接那些事儿</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/07/LLVM%20%E7%BC%96%E8%AF%91%E5%87%BA%E7%9A%84%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2%E7%A9%B6%E7%AB%9F%E9%9A%90%E8%97%8F%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F/">LLVM 编译出的目标文件里面究竟隐藏了些什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/28/%E5%BD%93%E6%88%91%E4%BB%AC%E6%8C%89%E4%B8%8BCommand+B%E5%90%8E%EF%BC%8CXcode%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/">当我们按下Command+B后，Xcode 做了什么？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/25/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">《程序员的自我修养》线程基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/25/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">《程序员的自我修养》基础知识</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">6</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">For_Minho.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>